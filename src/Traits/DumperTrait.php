<?php

declare(strict_types=1);

/*
 * This file is part of Flight Routing.
 *
 * PHP version 7.1 and above required
 *
 * @author    Divine Niiquaye Ibok <divineibok@gmail.com>
 * @copyright 2019 Biurad Group (https://biurad.com/)
 * @license   https://opensource.org/licenses/BSD-3-Clause License
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Flight\Routing\Traits;

use Flight\Routing\Interfaces\RouteInterface;
use Flight\Routing\Matchers\SimpleRouteMatcher;
use Flight\Routing\Route;

/**
 * @codeCoverageIgnore
 */
trait DumperTrait
{
    /**
     * @internal
     *
     * @param mixed $value
     */
    protected static function export($value): string
    {
        if (null === $value) {
            return 'null';
        }

        if (!\is_array($value)) {
            if ($value instanceof RouteInterface) {
                return self::exportRoute($value);
            }

            return \str_replace("\n", '\'."\n".\'', \var_export($value, true));
        }

        if (!$value) {
            return '[]';
        }

        $i      = 0;
        $export = '[';

        foreach ($value as $k => $v) {
            if ($i === $k) {
                ++$i;
            } else {
                $export .= self::export($k) . ' => ';

                if (\is_int($k) && $i < $k) {
                    $i = 1 + $k;
                }
            }

            if (\is_string($v) && 0 === \strpos($v, 'unserialize')) {
                $v = '\\' . $v . ', ';
            } elseif ($v instanceof RouteInterface) {
                $v .= self::exportRoute($v);
            } else {
                $v = self::export($v) . ', ';
            }

            $export .= $v;
        }

        return \substr_replace($export, ']', -2);
    }

    /**
     * @param RouteInterface $route
     *
     * @return string
     */
    protected static function exportRoute(RouteInterface $route): string
    {
        $controller = $route->getController();

        if (!\is_string($controller)) {
            $controller = \sprintf('unserialize(\'%s\')', \serialize($controller));
        }

        $exported = self::export([
            $route->getName(),
            $route->getMethods(),
            $route->getPath(),
            $route->getSchemes(),
            $route->getDomain(),
            $controller,
            $route->getMiddlewares(),
            $route->getPatterns(),
            $route->getDefaults(),
            $route->getArguments(),
        ]);

        return \sprintf('%s::__set_state(%s)', Route::class, $exported);
    }

    /**
     * Export the matcher, this method can be override if
     * RouteMatcherInterfaqce implementation changes.
     *
     * @param mixed $compiledRoutes
     *
     * @return string
     */
    protected function exportMatcher($compiledRoutes): string
    {
        $code = '';

        if ($this->matcher instanceof SimpleRouteMatcher) {
            [$staticRoutes, $dynamicRoutes] = $compiledRoutes;
            $code .= '[ // $staticRoutes' . "\n";

            foreach ($staticRoutes as $path => $route) {
                $code .= \sprintf('    %s => ', self::export($path));

                if (\is_array($route)) {
                    $code .= \sprintf(
                        "[\n        %s,\n        %s\n    ]",
                        self::export(\current($route)),
                        \sprintf('\unserialize(\'%s\')', \serialize(\end($route)))
                    );
                } else {
                    $code .= self::export($route);
                }
                $code .= ", \n";
            }
            $code .= "],\n";

            $code .= '[ // $dynamicRoutes' . "\n";

            foreach ($dynamicRoutes as $name => $route) {
                $code .= \sprintf('    %s =>', self::export($name));
                $code .= \sprintf(
                    "[\n        %s,\n        %s\n    ], \n",
                    self::export(\current($route)),
                    \sprintf('\unserialize(\'%s\')', \serialize(\end($route)))
                );
            }
            $code .= "],\n";
        } elseif (null !== $compiledRoutes || false !== $compiledRoutes) {
            $code .= self::export($compiledRoutes);
        }

        return $code;
    }

    /**
     * Warm up routes to speed up routes handling.
     *
     * @internal
     *
     * @param string $cacheFile
     */
    private function generateCompiledRoutes(string $cacheFile): void
    {
        $compiledRoutes = $this->matcher->warmCompiler($this->getCollection());

        $generatedCode = (string) \preg_replace(
            '/^./m',
            \str_repeat('    ', 1) . '$0',
            $this->exportMatcher($compiledRoutes)
        );

        $dumpCode = <<<EOF
<?php

/**
 * This file has been auto-generated by the Flight Routing.
 */

return [
{$generatedCode}];

EOF;

        \file_put_contents($cacheFile, $dumpCode);

        if (
            \function_exists('opcache_invalidate') &&
            \filter_var(\ini_get('opcache.enable'), \FILTER_VALIDATE_BOOLEAN)
        ) {
            @opcache_invalidate($cacheFile, true);
        }
    }
}
