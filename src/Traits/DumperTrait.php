<?php

declare(strict_types=1);

/*
 * This file is part of Flight Routing.
 *
 * PHP version 7.1 and above required
 *
 * @author    Divine Niiquaye Ibok <divineibok@gmail.com>
 * @copyright 2019 Biurad Group (https://biurad.com/)
 * @license   https://opensource.org/licenses/BSD-3-Clause License
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Flight\Routing\Traits;

use Flight\Routing\Interfaces\RouteMatcherInterface;
use Flight\Routing\Matchers\SimpleRouteMatcher;
use Flight\Routing\Route;

/**
 * @codeCoverageIgnore
 */
trait DumperTrait
{
    /**
     * @internal
     *
     * @param mixed $value
     */
    protected static function export($value): string
    {
        if (null === $value) {
            return 'null';
        }

        if (!\is_array($value)) {
            if ($value instanceof Route) {
                return self::exportRoute($value);
            }

            return \str_replace("\n", '\'."\n".\'', \var_export($value, true));
        }

        if (!$value) {
            return '[]';
        }

        $i      = 0;
        $export = '[';

        foreach ($value as $k => $v) {
            if ($i === $k) {
                ++$i;
            } else {
                $export .= self::export($k) . ' => ';

                if (\is_int($k) && $i < $k) {
                    $i = 1 + $k;
                }
            }

            if (\is_string($v) && 0 === \strpos($v, 'unserialize')) {
                $v = '\\' . $v . ', ';
            } elseif ($v instanceof Route) {
                $v .= self::exportRoute($v);
            } else {
                $v = self::export($v) . ', ';
            }

            $export .= $v;
        }

        return \substr_replace($export, ']', -2);
    }

    /**
     * @param Route $route
     *
     * @return string
     */
    protected static function exportRoute(Route $route): string
    {
        $properties = $route->getAll();

        if (!\is_string($controller = $properties['controller'])) {
            $properties['controller'] = \sprintf('unserialize(\'%s\')', \serialize($controller));
        }

        if (isset($properties['defaults']['_compiler'])) {
            $properties['defaults']['_compiler'] = \sprintf(
                'unserialize(\'%s\')',
                \serialize($properties['defaults']['_compiler'])
            );
        }

        $exported = self::export($properties);

        return \sprintf('%s::__set_state(%s)', Route::class, $exported);
    }

    /**
     * Export the matcher, this method can be override if
     * RouteMatcherInterfaqce implementation changes.
     *
     * @param mixed                 $compiledRoutes
     * @param RouteMatcherInterface $matcher
     *
     * @return string
     */
    protected function exportMatcher($compiledRoutes, RouteMatcherInterface $matcher): string
    {
        $code = '';

        if ($matcher instanceof SimpleRouteMatcher) {
            [$staticRoutes, $dynamicRoutes] = $compiledRoutes;
            $code .= '[ // $staticRoutes' . "\n";

            foreach ($staticRoutes as $path => $route) {
                $code .= \sprintf('    %s => ', self::export($path));
                $code .= self::export($route);
                $code .= ", \n";
            }
            $code .= "],\n";

            $code .= '[ // $dynamicRoutes' . "\n";

            foreach ($dynamicRoutes as $name => $route) {
                $code .= \sprintf('    %s => ', self::export($name));
                $code .= self::export($route);
                $code .= ", \n";
            }
            $code .= "],\n";
        } else {
            $code .= self::export($compiledRoutes);
        }

        return $code;
    }

    /**
     * Warm up routes to speed up routes handling.
     *
     * @internal
     *
     * @param string                $cacheFile
     * @param RouteMatcherInterface $matcher
     */
    private function generateCompiledRoutes(string $cacheFile, RouteMatcherInterface $matcher): void
    {
        if (false === $compiledRoutes = $matcher->getCompiledRoutes()) {
            return;
        }

        $generatedCode = (string) \preg_replace(
            '/^./m',
            \str_repeat('    ', 1) . '$0',
            $this->exportMatcher($compiledRoutes, $matcher)
        );

        $dumpCode = <<<EOF
<?php

/**
 * This file has been auto-generated by the Flight Routing.
 */

return [
{$generatedCode}];

EOF;

        \file_put_contents($cacheFile, $dumpCode);

        if (
            \function_exists('opcache_invalidate') &&
            \filter_var(\ini_get('opcache.enable'), \FILTER_VALIDATE_BOOLEAN)
        ) {
            @opcache_invalidate($cacheFile, true);
        }
    }
}
